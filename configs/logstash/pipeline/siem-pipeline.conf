input {
  # Beats input for Filebeat
  beats {
    port => 5044
  }
  
  # Syslog input for firewall and system logs
  syslog {
    port => 5000
    codec => cef
    tags => ["syslog", "firewall"]
  }
  
  # TCP input for application logs
  tcp {
    port => 5001
    codec => json_lines
    tags => ["tcp", "application"]
  }
  
  # File input for sample data during development
  file {
    path => "/usr/share/logstash/sample-data/*.log"
    start_position => "beginning"
    sincedb_path => "/dev/null"
    tags => ["sample-data"]
  }
}

filter {
  # Parse timestamps
  date {
    match => [ "timestamp", "ISO8601", "yyyy-MM-dd HH:mm:ss", "MMM dd HH:mm:ss" ]
    target => "@timestamp"
  }
  
  # Firewall log parsing
  if "firewall" in [tags] {
    grok {
      match => { 
        "message" => "%{SYSLOGTIMESTAMP:timestamp} %{IPORHOST:firewall_host} %{WORD:action} %{IP:src_ip}:%{INT:src_port} -> %{IP:dst_ip}:%{INT:dst_port} %{WORD:protocol}( %{GREEDYDATA:extra_info})?"
      }
    }
    
    mutate {
      add_field => { "log_type" => "firewall" }
      add_field => { "event_category" => "network" }
    }
    
    # GeoIP enrichment for source IP
    geoip {
      source => "src_ip"
      target => "src_geoip"
    }
    
    geoip {
      source => "dst_ip" 
      target => "dst_geoip"
    }
  }
  
  # Authentication log parsing
  if "auth" in [tags] or [log][file][path] =~ /auth/ {
    grok {
      match => { 
        "message" => "%{SYSLOGTIMESTAMP:timestamp} %{IPORHOST:host} %{WORD:service}: %{WORD:auth_result} for %{USERNAME:user} from %{IP:src_ip}"
      }
    }
    
    mutate {
      add_field => { "log_type" => "authentication" }
      add_field => { "event_category" => "authentication" }
    }
    
    # Failed login detection
    if [auth_result] == "Failed" {
      mutate {
        add_field => { "security_alert" => "failed_login" }
        add_field => { "severity" => "medium" }
      }
    }
    
    # GeoIP for authentication attempts
    geoip {
      source => "src_ip"
      target => "src_geoip"
    }
  }
  
  # IDS/IPS log parsing
  if "ids" in [tags] {
    grok {
      match => { 
        "message" => "%{TIMESTAMP_ISO8601:timestamp} \[%{INT:alert_id}\] %{WORD:severity}: %{DATA:alert_msg} %{IP:src_ip}:%{INT:src_port} -> %{IP:dst_ip}:%{INT:dst_port}"
      }
    }
    
    mutate {
      add_field => { "log_type" => "ids" }
      add_field => { "event_category" => "intrusion_detection" }
    }
    
    # Threat severity mapping
    if [severity] == "HIGH" {
      mutate {
        add_field => { "security_alert" => "high_severity_threat" }
        add_field => { "priority" => "1" }
      }
    }
  }
  
  # Web access log parsing
  if "web" in [tags] or [log][file][path] =~ /access/ {
    grok {
      match => { 
        "message" => "%{COMBINEDAPACHELOG}"
      }
    }
    
    mutate {
      add_field => { "log_type" => "web_access" }
      add_field => { "event_category" => "web" }
    }
    
    # Detect suspicious HTTP status codes
    if [response] >= 400 {
      mutate {
        add_field => { "security_alert" => "http_error" }
        add_field => { "severity" => "low" }
      }
    }
    
    # SQL injection detection
    if [request] =~ /(?i)(union|select|insert|delete|update|drop|exec|script)/ {
      mutate {
        add_field => { "security_alert" => "potential_sql_injection" }
        add_field => { "severity" => "high" }
      }
    }
  }
  
  # Add common enrichment fields
  mutate {
    add_field => { "[@metadata][index]" => "siem-logs-%{+YYYY.MM.dd}" }
    add_field => { "ingestion_timestamp" => "%{@timestamp}" }
  }
  
  # Remove unnecessary fields
  mutate {
    remove_field => [ "host", "agent", "ecs", "input" ]
  }
}

output {
  # Output to Elasticsearch
  elasticsearch {
    hosts => ["elasticsearch:9200"]
    index => "%{[@metadata][index]}"
    template_name => "siem-logs"
    template_pattern => "siem-logs-*"
    template => {
      "index_patterns" => ["siem-logs-*"],
      "settings" => {
        "number_of_shards" => 1,
        "number_of_replicas" => 0,
        "index.refresh_interval" => "30s"
      },
      "mappings" => {
        "properties" => {
          "@timestamp" => { "type" => "date" },
          "log_type" => { "type" => "keyword" },
          "event_category" => { "type" => "keyword" },
          "src_ip" => { "type" => "ip" },
          "dst_ip" => { "type" => "ip" },
          "src_port" => { "type" => "integer" },
          "dst_port" => { "type" => "integer" },
          "severity" => { "type" => "keyword" },
          "security_alert" => { "type" => "keyword" },
          "src_geoip" => {
            "properties" => {
              "location" => { "type" => "geo_point" },
              "country_name" => { "type" => "keyword" },
              "city_name" => { "type" => "keyword" }
            }
          }
        }
      }
    }
  }
  
  # Debug output to stdout (remove in production)
  stdout {
    codec => rubydebug { metadata => true }
  }
}
